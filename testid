#!/usr/bin/env python

import base64, hashlib, hmac, os, pickle, time, urllib
from lxml import etree
from random import random
from twisted.internet import reactor, tcp
from twisted.web import resource, server

root = resource.Resource()

def rndstr(length, alphabet):
  result = ''

  # Choose symbols from alphabet at random
  symbol = random()
  for _ in range(length):
    symbol *= len(alphabet)
    result += alphabet[int(symbol)]
    symbol -= int(symbol)

  return result

# segment       = *pchar
# pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
# unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
# sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
#               / "*" / "+" / "," / ";" / "="
segment = rndstr(6, '!$&\'()*+,-.' + ''.join(map(chr, range(48, 58))) + ':;=@' + ''.join(map(chr, range(65, 91))) + '_' + ''.join(map(chr, range(97, 123))) + '~')

class claimedIdentifier(resource.Resource):
  def render(ctx, request):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    request.setHeader('Content-Type', 'application/xrds+xml')

    return ''.join((
      '<XRDS xmlns="xri://$xrds">',
        '<XRD xmlns="xri://$xrd*($v*2.0)">',
          '<Service>',
            '<Type>http://specs.openid.net/auth/2.0/signon</Type>',
            '<URI>http://{}{}/{}</URI>'.format(host, base, segment),
          '</Service>',
        '</XRD>',
      '</XRDS>'))

class opEndpoint(resource.Resource):
  shared = {}

  def associate(ctx, request, params):

    # ASCII characters in the range 33-126 inclusive (printable non-whitespace
    # characters)
    assocHandle = rndstr(6, map(chr, range(33, 126 + 1)))

    try:
      g = base64Dec(params['openid.dh_gen'])

    except KeyError:
      g = 2

    try:
      p = base64Dec(params['openid.dh_modulus'])

    except KeyError:

      # This is a confirmed-prime number, used as the default modulus for
      # Diffie-Hellman Key Exchange
      p = 0xdcf93a0b883972ec0e19989ac5a2ce310e1d37717e8d9571bb7623731866e61ef75a2e27898b057f9891c2e27a639c3f29b60814581cd3b2ca3986d2683705577d45c2e7e52dc81c7a171876e5cea74b1448bfdfaf18828efd2519f14e45e3826634af1949e5b535cc829a483b8a76223e5d490a257f05bdff16f2fb22c583ab

    # Random private key xb in the range [1 .. p-1]
    xb = int(random() * p)

    dhServerPublic = base64Enc(pow(g, xb, p))

    # The MAC key MUST be the same length as the output of H, the hash function
    # - 160 bits (20 bytes) for DH-SHA1 or 256 bits (32 bytes) for DH-SHA256,
    # as well as the output of the signature algorithm of this association

    if str(params['openid.session_type']) == 'DH-SHA1':
      H = hashlib.sha1()

      if str(params['openid.assoc_type']) == 'HMAC-SHA1':
        key = os.urandom(20)
        ctx.shared[assocHandle] = key, hashlib.sha1

    elif str(params['openid.session_type']) == 'DH-SHA256':
      H = hashlib.sha256()

      if str(params['openid.assoc_type']) == 'HMAC-SHA256':
        key = os.urandom(32)
        ctx.shared[assocHandle] = key, hashlib.sha256

    H.update(btwocEnc(pow(base64Dec(params['openid.dh_consumer_public']), xb, p)))
    encMacKey = base64.b64encode(''.join(chr(ord(digest) ^ ord(key)) for digest, key in zip(H.digest(), key)))

    # 14 days in seconds
    expiresIn = 14 * 24 * 60 * 60

    return '\n'.join(map(':'.join, (
      ('assoc_handle', assocHandle),
      ('assoc_type', str(params['openid.assoc_type'])),
      ('dh_server_public', dhServerPublic),
      ('enc_mac_key', encMacKey),
      ('expires_in', str(expiresIn)),
      ('ns', 'http://specs.openid.net/auth/2.0'),
      ('session_type', str(params['openid.session_type']))))) + '\n'

  def checkidSetup(ctx, request, params):
    host, = request.requestHeaders.getRawHeaders('Host')

    assocHandle = str(params['openid.assoc_handle'])
    returnTo = str(params['openid.return_to'])

    signed = [
      ('assoc_handle', assocHandle),
      ('claimed_id', str(params['openid.claimed_id'])),
      ('identity', str(params['openid.identity'])),
      ('op_endpoint', 'http://{}{}'.format(host, request.path)),
      ('response_nonce', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
      ('return_to', returnTo)]

    key, digestmod = ctx.shared[assocHandle]

    signed.extend((
      ('mode', 'id_res'),
      ('ns', 'http://specs.openid.net/auth/2.0'),
      ('sig', base64.b64encode(hmac.new(key, '\n'.join(map(':'.join, signed)) + '\n', digestmod).digest())),
      ('signed', ','.join(field for field, _ in signed))))

    form = etree.Element('form', action=returnTo, method='post')
    for k, v in signed:
      form.append(etree.Element('input', name='openid.' + k, value=v))

    return etree.tostring(form) + '<script>document.forms[0].submit()</script>'

  checkAuthentication = lambda ctx, request, params: '\n'.join(map(':'.join, (
    ('is_valid', 'true'),
    ('ns', 'http://specs.openid.net/auth/2.0')))) + '\n'

  def render(ctx, request):
    if request.method == 'POST':
      request.content.seek(0)
      params = urlencoded(request.content.read())

    else:
      _, query = request.uri.split('?', 1)
      params = urlencoded(query)

    mode = str(params['openid.mode'])
    if mode == 'associate':
      return ctx.associate(request, params)

    elif mode == 'checkid_setup':
      return ctx.checkidSetup(request, params)

    elif mode == 'check_authentication':
      return ctx.checkAuthentication(request, params)

child = claimedIdentifier()
child.putChild(segment, opEndpoint())
root.putChild('smokeTest', child)

# If the Relying Party does not have an association stored, it MUST request
# that the OP verify the signature via Direct Verification

class directVerificationOpEndpoint(opEndpoint):
  def checkidSetup(ctx, request, params):
    host, = request.requestHeaders.getRawHeaders('Host')

    # ASCII characters in the range 33-126 inclusive (printable non-whitespace
    # characters)
    assocHandle = rndstr(6, map(chr, range(33, 126 + 1)))

    returnTo = str(params['openid.return_to'])

    signed = [
      ('assoc_handle', assocHandle),
      ('claimed_id', str(params['openid.claimed_id'])),
      ('identity', str(params['openid.identity'])),
      ('op_endpoint', 'http://{}{}'.format(host, request.path)),
      ('response_nonce', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
      ('return_to', returnTo)]

    key = os.urandom(32)
    digestmod = hashlib.sha256

    signed.extend((
      ('mode', 'id_res'),
      ('ns', 'http://specs.openid.net/auth/2.0'),
      ('sig', base64.b64encode(hmac.new(key, '\n'.join(map(':'.join, signed)) + '\n', digestmod).digest())),
      ('signed', ','.join(field for field, _ in signed))))

    form = etree.Element('form', action=returnTo, method='post')
    for k, v in signed:
      form.append(etree.Element('input', name='openid.' + k, value=v))

    return etree.tostring(form) + '<script>document.forms[0].submit()</script>'

child = claimedIdentifier()
child.putChild(segment, directVerificationOpEndpoint())
root.putChild('directVerification', child)

# For the purposes of making OpenID Authentication requests, the value
# "http://specs.openid.net/auth/2.0/identifier_select" MUST be used as both the
# Claimed Identifier and the OP-Local Identifier when an OP Identifier is
# entered

class opIdentifier(resource.Resource):
  def render(ctx, request):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    request.setHeader('Content-Type', 'application/xrds+xml')

    return ''.join((
      '<XRDS xmlns="xri://$xrds">',
        '<XRD xmlns="xri://$xrd*($v*2.0)">',
          '<Service>',
            '<Type>http://specs.openid.net/auth/2.0/server</Type>',
            '<URI>http://{}{}/{}</URI>'.format(host, base, segment),
          '</Service>',
        '</XRD>',
      '</XRDS>'))

class identifierSelectOpEndpoint(opEndpoint):
  def checkidSetup(ctx, request, params):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    assocHandle = str(params['openid.assoc_handle'])
    returnTo = str(params['openid.return_to'])

    signed = [
      ('assoc_handle', assocHandle),
      ('claimed_id', 'http://{}{}/claimedIdentifier'.format(host, base)),
      ('identity', 'http://{}{}/claimedIdentifier'.format(host, base)),
      ('op_endpoint', 'http://{}{}'.format(host, request.path)),
      ('response_nonce', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
      ('return_to', returnTo)]

    key, digestmod = ctx.shared[assocHandle]

    signed.extend((
      ('mode', 'id_res'),
      ('ns', 'http://specs.openid.net/auth/2.0'),
      ('sig', base64.b64encode(hmac.new(key, '\n'.join(map(':'.join, signed)) + '\n', digestmod).digest())),
      ('signed', ','.join(field for field, _ in signed))))

    form = etree.Element('form', action=returnTo, method='post')
    for k, v in signed:
      form.append(etree.Element('input', name='openid.' + k, value=v))

    return etree.tostring(form) + '<script>document.forms[0].submit()</script>'

child = opIdentifier()
child.putChild(segment, identifierSelectOpEndpoint())
child.putChild('claimedIdentifier', claimedIdentifier())
root.putChild('identifierSelect', child)

# The attribute exchange namespace "http://openid.net/srv/ax/1.0" SHOULD be
# listed as an <xrd:Type> child element of the <xrd:Service> element in the
# XRDS discovery document

class attributeExchangeClaimedIdentifier(resource.Resource):
  def render(ctx, request):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    request.setHeader('Content-Type', 'application/xrds+xml')

    return ''.join((
      '<XRDS xmlns="xri://$xrds">',
        '<XRD xmlns="xri://$xrd*($v*2.0)">',
          '<Service>',
            '<Type>http://specs.openid.net/auth/2.0/signon</Type>',
            '<Type>http://openid.net/srv/ax/1.0</Type>',
            '<URI>http://{}{}/{}</URI>'.format(host, base, segment),
          '</Service>',
        '</XRD>',
      '</XRDS>'))

child = attributeExchangeClaimedIdentifier()
child.putChild(segment, opEndpoint())
root.putChild('attributeExchange', child)

class attributeExchangeOpIdentifier(resource.Resource):
  def render(ctx, request):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    request.setHeader('Content-Type', 'application/xrds+xml')

    return ''.join((
      '<XRDS xmlns="xri://$xrds">',
        '<XRD xmlns="xri://$xrd*($v*2.0)">',
          '<Service>',
            '<Type>http://specs.openid.net/auth/2.0/server</Type>',
            '<Type>http://openid.net/srv/ax/1.0</Type>',
            '<URI>http://{}{}/{}</URI>'.format(host, base, segment),
          '</Service>',
        '</XRD>',
      '</XRDS>'))

class bigBangOpEndpoint(opEndpoint):
  def checkidSetup(ctx, request, params):
    host, = request.requestHeaders.getRawHeaders('Host')

    try:
      end = request.path.index('/', 1)

    except ValueError:
      base = request.path

    else:
      base = request.path[:end]

    # ASCII characters in the range 33-126 inclusive (printable non-whitespace
    # characters)
    assocHandle = rndstr(6, map(chr, range(33, 126 + 1)))

    returnTo = str(params['openid.return_to'])

    signed = [
      ('assoc_handle', assocHandle),
      ('claimed_id', 'http://{}{}/claimedIdentifier'.format(host, base)),
      ('identity', 'http://{}{}/claimedIdentifier'.format(host, base)),
      ('op_endpoint', 'http://{}{}'.format(host, request.path)),
      ('response_nonce', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
      ('return_to', returnTo)]

    key = os.urandom(32)
    digestmod = hashlib.sha256

    signed.extend((
      ('mode', 'id_res'),
      ('ns', 'http://specs.openid.net/auth/2.0'),
      ('sig', base64.b64encode(hmac.new(key, '\n'.join(map(':'.join, signed)) + '\n', digestmod).digest())),
      ('signed', ','.join(field for field, _ in signed))))

    form = etree.Element('form', action=returnTo, method='post')
    for k, v in signed:
      form.append(etree.Element('input', name='openid.' + k, value=v))

    return etree.tostring(form) + '<script>document.forms[0].submit()</script>'

child = attributeExchangeOpIdentifier()
child.putChild(segment, bigBangOpEndpoint())
child.putChild('claimedIdentifier', attributeExchangeClaimedIdentifier())
root.putChild('bigBang', child)

btwocDec = lambda arg: pickle.decode_long(arg[::-1])
btwocEnc = lambda arg: pickle.encode_long(arg)[::-1] if arg else '\x00'

base64Dec = lambda arg: btwocDec(base64.b64decode(arg.replace('-', '+').replace('_', '/')))
base64Enc = lambda arg: base64.b64encode(btwocEnc(arg))

class oneMany:
  def __init__(ctx, *args):
    ctx.nst = args

  def __getattr__(ctx, name):
    try:
      return getattr(ctx.nst, name)

    except AttributeError:
      one, = ctx.nst

      return getattr(one, name)

  def __getitem__(ctx, name):
    try:
      return ctx.nst[name]

    except KeyError:
      one, = ctx.nst

      return one[name]

  def __str__(ctx):
    one, = ctx.nst

    return str(one)

class manyMap:
  def __init__(ctx, *args, **kwds):
    ctx.nst = dict()

    for k, v in args:
      ctx.push(k, v)

    for k, v in kwds.iteritems():
      ctx.push(k, v)

  def push(ctx, name, *args):
    try:
      ctx.nst[name].extend(*args)

    except KeyError:
      ctx.nst[name] = oneMany(*args)

  def __getattr__(ctx, name):
    try:
      return getattr(ctx.nst, name)

    except AttributeError:
      try:
        return ctx.nst[name]

      except KeyError:
        raise AttributeError

  def __getitem__(ctx, name):
    try:
      return ctx.nst[name]

    except KeyError:
      try:
        return getattr(ctx.nst, name)

      except AttributeError:
        raise KeyError

urlencoded = lambda arg: manyMap(*(map(urllib.unquote_plus, pair.split('=', 1)) for pair in arg.split('&')))

tcp.Port(2269, server.Site(root)).startListening()

reactor.run()
